{"ast":null,"code":"import _objectSpread from \"/Volumes/GithubWorkspace/datatable-translatable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nexport var parseDataTables = function parseDataTables(_ref) {\n  var original = _ref.original,\n      translation = _ref.translation,\n      compositeKeyIndices = _ref.compositeKeyIndices,\n      rowDelimiter = _ref.rowDelimiter,\n      cellDelimiter = _ref.cellDelimiter;\n  var data = [];\n  var originalDataTable = parseDataTable({\n    table: original,\n    rowDelimiter: rowDelimiter,\n    cellDelimiter: cellDelimiter\n  });\n  var translationDataTable = parseDataTable({\n    table: translation,\n    rowDelimiter: rowDelimiter,\n    cellDelimiter: cellDelimiter\n  });\n\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    var index = {};\n    originalDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      index[componsiteKey] = {\n        original: row\n      };\n    });\n    translationDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      index[componsiteKey] = _objectSpread({\n        translation: row\n      }, index[componsiteKey]);\n    });\n    data = Object.values(index).map(function (row) {\n      return row.map(function (cell) {\n        return \"\".concat(cell.original, \"\\t\").concat(cell.translation);\n      });\n    });\n  }\n\n  return {\n    columnNames: originalDataTable.columnNames,\n    data: data\n  };\n};\nexport var parseDataTable = function parseDataTable(_ref2) {\n  var table = _ref2.table,\n      rowDelimiter = _ref2.rowDelimiter,\n      cellDelimiter = _ref2.cellDelimiter;\n  var rows = parseRows({\n    table: table,\n    delimiter: rowDelimiter\n  }).map(function (row) {\n    return parseCells({\n      row: row,\n      delimiter: cellDelimiter\n    });\n  });\n  var dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows)\n  };\n  return dataTable;\n};\nexport var getColumnNames = function getColumnNames(rows) {\n  return rows[0];\n};\nexport var getData = function getData(rows) {\n  return rows.slice(1);\n};\nexport var parseRows = function parseRows(_ref3) {\n  var table = _ref3.table,\n      delimiter = _ref3.delimiter;\n  return table.split(delimiter);\n};\nexport var parseCells = function parseCells(_ref4) {\n  var row = _ref4.row,\n      delimiter = _ref4.delimiter;\n  return row.split(delimiter);\n};","map":{"version":3,"sources":["/Volumes/GithubWorkspace/datatable-translatable/src/components/datatable/helpers.js"],"names":["parseDataTables","original","translation","compositeKeyIndices","rowDelimiter","cellDelimiter","data","originalDataTable","parseDataTable","table","translationDataTable","columnNames","length","index","forEach","row","componsiteKey","map","join","Object","values","cell","rows","parseRows","delimiter","parseCells","dataTable","getColumnNames","getData","slice","split"],"mappings":"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","sourcesContent":["\n\nexport const parseDataTables = ({original, translation, compositeKeyIndices, rowDelimiter, cellDelimiter}) => {\n  let data = [];\n  const originalDataTable = parseDataTable({table: original, rowDelimiter, cellDelimiter});\n  const translationDataTable = parseDataTable({table: translation, rowDelimiter, cellDelimiter})\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    let index = {};\n    originalDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      index[componsiteKey] = { original: row };\n    });\n    translationDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      index[componsiteKey] = { translation: row, ...index[componsiteKey]};\n    });\n\n    data = Object.values(index).map(row => \n      row.map(cell => `${cell.original}\\t${cell.translation}`)\n    );\n  }\n  return {\n    columnNames: originalDataTable.columnNames,\n    data,\n  };\n}\n\nexport const parseDataTable = ({table, rowDelimiter, cellDelimiter}) => {\n  const rows = parseRows({table, delimiter: rowDelimiter})\n  .map(row =>\n    parseCells({row, delimiter: cellDelimiter})\n  );\n  const dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows),\n  }\n  return dataTable;\n};\n\nexport const getColumnNames = (rows) => rows[0];\nexport const getData = (rows) => rows.slice(1);\n\nexport const parseRows = ({table, delimiter}) => table.split(delimiter);\nexport const parseCells = ({row, delimiter}) => row.split(delimiter);"]},"metadata":{},"sourceType":"module"}