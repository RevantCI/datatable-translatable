{"ast":null,"code":"import _objectSpread from \"/Volumes/GithubWorkspace/datatable-translatable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nexport var parseDataTables = function parseDataTables(_ref) {\n  var original = _ref.original,\n      translation = _ref.translation,\n      compositeKeyIndices = _ref.compositeKeyIndices,\n      delimiters = _ref.delimiters,\n      columnsFilter = _ref.columnsFilter;\n  var data = [];\n  var originalDataTable = parseDataTable({\n    table: original,\n    delimiters: delimiters\n  });\n  var translationDataTable = parseDataTable({\n    table: translation,\n    delimiters: delimiters\n  });\n\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    var rowIndex = {};\n    originalDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = {\n        original: row\n      };\n    });\n    translationDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = _objectSpread({\n        translation: row\n      }, rowIndex[componsiteKey]);\n    });\n    data = Object.values(rowIndex).map(function (row) {\n      var _row = row.original.map(function (originalCell, index) {\n        var translationCell = row.translation[index];\n        var value = originalCell;\n\n        if (!columnsFilter.includes(index)) {\n          value = \"\".concat(originalCell, \"\\t\").concat(translationCell);\n        }\n\n        return value;\n      });\n\n      return _row;\n    });\n  }\n\n  return {\n    columnNames: originalDataTable.columnNames,\n    data: data\n  };\n};\nexport var parseDataTable = function parseDataTable(_ref2) {\n  var table = _ref2.table,\n      delimiters = _ref2.delimiters;\n  var rows = parseRows({\n    table: table,\n    delimiter: delimiters.row\n  }).map(function (row) {\n    return parseCells({\n      row: row,\n      delimiter: delimiters.cell\n    });\n  });\n  var dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows)\n  };\n  return dataTable;\n};\nexport var getColumnNames = function getColumnNames(rows) {\n  return rows[0];\n};\nexport var getData = function getData(rows) {\n  return rows.slice(1);\n};\nexport var parseRows = function parseRows(_ref3) {\n  var table = _ref3.table,\n      delimiter = _ref3.delimiter;\n  return table.split(delimiter);\n};\nexport var parseCells = function parseCells(_ref4) {\n  var row = _ref4.row,\n      delimiter = _ref4.delimiter;\n  return row.split(delimiter);\n};","map":{"version":3,"sources":["/Volumes/GithubWorkspace/datatable-translatable/src/components/datatable/helpers.js"],"names":["parseDataTables","original","translation","compositeKeyIndices","delimiters","columnsFilter","data","originalDataTable","parseDataTable","table","translationDataTable","columnNames","length","rowIndex","forEach","row","componsiteKey","map","index","join","Object","values","_row","originalCell","translationCell","value","includes","rows","parseRows","delimiter","parseCells","cell","dataTable","getColumnNames","getData","slice","split"],"mappings":"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","sourcesContent":["\n\nexport const parseDataTables = ({original, translation, compositeKeyIndices, delimiters, columnsFilter}) => {\n  let data = [];\n  const originalDataTable = parseDataTable({table: original, delimiters});\n  const translationDataTable = parseDataTable({table: translation, delimiters})\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    let rowIndex = {};\n    originalDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { original: row };\n    });\n    translationDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { translation: row, ...rowIndex[componsiteKey]};\n    });\n\n    data = Object.values(rowIndex).map(row => {\n      const _row = row.original.map((originalCell, index) => {\n        const translationCell = row.translation[index];\n        let value = originalCell;\n        if (!columnsFilter.includes(index)) {\n          value = `${originalCell}\\t${translationCell}`;\n        }\n        return value;\n      });\n      return _row;\n    });\n  }\n  return {\n    columnNames: originalDataTable.columnNames,\n    data,\n  };\n}\n\nexport const parseDataTable = ({table, delimiters}) => {\n  const rows = parseRows({table, delimiter: delimiters.row})\n  .map(row =>\n    parseCells({row, delimiter: delimiters.cell})\n  );\n  const dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows),\n  }\n  return dataTable;\n};\n\nexport const getColumnNames = (rows) => rows[0];\nexport const getData = (rows) => rows.slice(1);\n\nexport const parseRows = ({table, delimiter}) => table.split(delimiter);\nexport const parseCells = ({row, delimiter}) => row.split(delimiter);"]},"metadata":{},"sourceType":"module"}