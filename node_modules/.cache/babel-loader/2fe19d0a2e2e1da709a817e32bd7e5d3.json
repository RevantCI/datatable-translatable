{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styles = require(\"@material-ui/core/styles\");\n\nvar _md = _interopRequireDefault(require(\"md5\"));\n\nvar _sectionTranslatable = _interopRequireDefault(require(\"../section-translatable\"));\n\nvar helpers = _interopRequireWildcard(require(\"./helpers\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n} // const whyDidYouRender = (process.env.NODE_ENV !== 'production') ?\n//   require('@welldone-software/why-did-you-render') : undefined;\n// if (whyDidYouRender) whyDidYouRender(React);\n\n/**\n * ### A reusable component for translating a Markdown document.\n * @component\n */\n\n\nfunction DocumentTranslatable(_ref) {\n  var classes = _ref.classes,\n      original = _ref.original,\n      translation = _ref.translation,\n      inputFilters = _ref.inputFilters,\n      outputFilters = _ref.outputFilters,\n      onTranslation = _ref.onTranslation,\n      style = _ref.style;\n\n  var _useState = (0, _react.useState)(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      sectionFocus = _useState2[0],\n      setSectionFocus = _useState2[1];\n\n  var originalSections = helpers.sectionsFromMarkdown({\n    markdown: original\n  });\n\n  var __translationSections = helpers.sectionsFromMarkdown({\n    markdown: translation\n  });\n\n  var _useState3 = (0, _react.useState)(__translationSections),\n      _useState4 = _slicedToArray(_useState3, 2),\n      translationSections = _useState4[0],\n      setTranslationSections = _useState4[1];\n\n  var setTranslationSection = function setTranslationSection(_ref2) {\n    var index = _ref2.index,\n        translationSection = _ref2.translationSection;\n    setSectionFocus(index);\n\n    var _translationSections = _toConsumableArray(translationSections);\n\n    _translationSections[index] = translationSection;\n    setTranslationSections(_translationSections);\n\n    var _translation = helpers.markdownFromSections({\n      sections: _translationSections\n    });\n\n    onTranslation(_translation);\n  };\n\n  var sectionTranslatables = originalSections.map(function (originalSection, index) {\n    var key = index + (0, _md[\"default\"])(JSON.stringify(originalSection));\n    var translationSection = translationSections[index];\n\n    var _onTranslation = function _onTranslation(_translationSection) {\n      return setTranslationSection({\n        index: index,\n        translationSection: _translationSection\n      });\n    };\n\n    var _onSectionFocus = function _onSectionFocus(expanded) {\n      if (expanded) setSectionFocus(index);else setSectionFocus(null);\n    };\n\n    var _sectionFocus = sectionFocus === index;\n\n    return _react[\"default\"].createElement(_sectionTranslatable[\"default\"], {\n      key: key,\n      original: originalSection,\n      translation: translationSection,\n      inputFilters: inputFilters,\n      outputFilters: outputFilters,\n      onTranslation: _onTranslation,\n      onSectionFocus: _onSectionFocus,\n      sectionFocus: _sectionFocus,\n      style: style\n    });\n  });\n  return _react[\"default\"].createElement(_react[\"default\"].Fragment, null, sectionTranslatables);\n}\n\n;\nDocumentTranslatable.propTypes = {\n  /** Original markdown for the editor. */\n  original: _propTypes[\"default\"].string.isRequired,\n\n  /** Translation markdown for the editor. */\n  translation: _propTypes[\"default\"].string.isRequired,\n\n  /** Function to propogate changes to the translation. */\n  onTranslation: _propTypes[\"default\"].func.isRequired,\n\n  /** Replace strings before rendering. */\n  inputFilters: _propTypes[\"default\"].array,\n\n  /** Replace strings after editing. */\n  outputFilters: _propTypes[\"default\"].array,\n\n  /** CSS for the component. */\n  style: _propTypes[\"default\"].object\n};\nDocumentTranslatable.defaultProps = {\n  original: '',\n  translation: '',\n  onTranslation: function onTranslation() {},\n  inputFilters: [],\n  outputFilters: [],\n  style: {}\n};\n\nvar styles = function styles(theme) {\n  return {\n    root: {},\n    details: {\n      display: 'block',\n      padding: '0',\n      borderTop: '1px solid #ccc',\n      borderBottom: '1px solid #ccc'\n    }\n  };\n};\n\nvar areEqual = function areEqual(prevProps, nextProps) {\n  var keys = ['original', 'translation', 'style'];\n  var checks = keys.map(function (key) {\n    return JSON.stringify(prevProps[key]) === JSON.stringify(nextProps[key]);\n  });\n  var equal = !checks.includes(false); // console.log('DocumentTranslatable', keys, checks, equal);\n\n  return equal;\n}; // DocumentTranslatable.whyDidYouRender = true;\n\n\nvar StyleComponent = (0, _styles.withStyles)(styles)(DocumentTranslatable);\n\nvar MemoComponent = _react[\"default\"].memo(StyleComponent, areEqual);\n\nvar _default = MemoComponent;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}