{"ast":null,"code":"import _objectSpread from \"/Volumes/GithubWorkspace/datatable-translatable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nexport var parseDataTables = function parseDataTables(_ref) {\n  var original = _ref.original,\n      translation = _ref.translation,\n      compositeKeyIndices = _ref.compositeKeyIndices,\n      rowDelimiter = _ref.rowDelimiter,\n      cellDelimiter = _ref.cellDelimiter;\n  var data = [];\n  var originalDataTable = parseDataTable({\n    table: original,\n    rowDelimiter: rowDelimiter,\n    cellDelimiter: cellDelimiter\n  });\n  var translationDataTable = parseDataTable({\n    table: translation,\n    rowDelimiter: rowDelimiter,\n    cellDelimiter: cellDelimiter\n  });\n\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    var rowIndex = {};\n    originalDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = {\n        original: row\n      };\n    });\n    translationDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = _objectSpread({\n        translation: row\n      }, rowIndex[componsiteKey]);\n    });\n    data = Object.values(rowIndex).map(function (row) {\n      var _row = row.original.map(function (originalCell, index) {\n        var translationCell = row.translation[index];\n        return \"\".concat(originalCell, \"\\t\").concat(translationCell);\n      });\n\n      return _row;\n    });\n  }\n\n  return {\n    columnNames: originalDataTable.columnNames,\n    data: data\n  };\n};\nexport var parseDataTable = function parseDataTable(_ref2) {\n  var table = _ref2.table,\n      rowDelimiter = _ref2.rowDelimiter,\n      cellDelimiter = _ref2.cellDelimiter;\n  var rows = parseRows({\n    table: table,\n    delimiter: rowDelimiter\n  }).map(function (row) {\n    return parseCells({\n      row: row,\n      delimiter: cellDelimiter\n    });\n  });\n  var dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows)\n  };\n  return dataTable;\n};\nexport var getColumnNames = function getColumnNames(rows) {\n  return rows[0];\n};\nexport var getData = function getData(rows) {\n  return rows.slice(1);\n};\nexport var parseRows = function parseRows(_ref3) {\n  var table = _ref3.table,\n      delimiter = _ref3.delimiter;\n  return table.split(delimiter);\n};\nexport var parseCells = function parseCells(_ref4) {\n  var row = _ref4.row,\n      delimiter = _ref4.delimiter;\n  return row.split(delimiter);\n};","map":{"version":3,"sources":["/Volumes/GithubWorkspace/datatable-translatable/src/components/datatable/helpers.js"],"names":["parseDataTables","original","translation","compositeKeyIndices","rowDelimiter","cellDelimiter","data","originalDataTable","parseDataTable","table","translationDataTable","columnNames","length","rowIndex","forEach","row","componsiteKey","map","index","join","Object","values","_row","originalCell","translationCell","rows","parseRows","delimiter","parseCells","dataTable","getColumnNames","getData","slice","split"],"mappings":"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","sourcesContent":["\n\nexport const parseDataTables = ({original, translation, compositeKeyIndices, rowDelimiter, cellDelimiter}) => {\n  let data = [];\n  const originalDataTable = parseDataTable({table: original, rowDelimiter, cellDelimiter});\n  const translationDataTable = parseDataTable({table: translation, rowDelimiter, cellDelimiter})\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    let rowIndex = {};\n    originalDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { original: row };\n    });\n    translationDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { translation: row, ...rowIndex[componsiteKey]};\n    });\n\n    data = Object.values(rowIndex).map(row => {\n      const _row = row.original.map((originalCell, index) => {\n        const translationCell = row.translation[index];\n        return `${originalCell}\\t${translationCell}`;\n      });\n      return _row;\n    });\n  }\n  return {\n    columnNames: originalDataTable.columnNames,\n    data,\n  };\n}\n\nexport const parseDataTable = ({table, rowDelimiter, cellDelimiter}) => {\n  const rows = parseRows({table, delimiter: rowDelimiter})\n  .map(row =>\n    parseCells({row, delimiter: cellDelimiter})\n  );\n  const dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows),\n  }\n  return dataTable;\n};\n\nexport const getColumnNames = (rows) => rows[0];\nexport const getData = (rows) => rows.slice(1);\n\nexport const parseRows = ({table, delimiter}) => table.split(delimiter);\nexport const parseCells = ({row, delimiter}) => row.split(delimiter);"]},"metadata":{},"sourceType":"module"}