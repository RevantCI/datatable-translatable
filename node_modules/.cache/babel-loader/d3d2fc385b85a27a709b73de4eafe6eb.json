{"ast":null,"code":"import _objectSpread from \"/Volumes/GithubWorkspace/datatable-translatable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nexport var parseDataTables = function parseDataTables(_ref) {\n  var original = _ref.original,\n      translation = _ref.translation,\n      compositeKeyIndices = _ref.compositeKeyIndices,\n      delimiters = _ref.delimiters;\n  var data = [];\n  var originalDataTable = parseDataTable({\n    table: original,\n    delimiters: delimiters\n  });\n  var translationDataTable = parseDataTable({\n    table: translation,\n    delimiters: delimiters\n  });\n\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    var rowIndex = {};\n    originalDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = {\n        original: row\n      };\n    });\n    translationDataTable.data.forEach(function (row) {\n      var componsiteKey = compositeKeyIndices.map(function (index) {\n        return row[index];\n      }).join(':');\n      rowIndex[componsiteKey] = _objectSpread({\n        translation: row\n      }, rowIndex[componsiteKey]);\n    });\n    data = Object.values(rowIndex).map(function (row) {\n      var _row = row.original.map(function (originalCell, index) {\n        var translationCell = row.translation[index];\n        return \"\".concat(originalCell, \"\\t\").concat(translationCell);\n      });\n\n      return _row;\n    });\n  }\n\n  return {\n    columnNames: originalDataTable.columnNames,\n    data: data\n  };\n};\nexport var parseDataTable = function parseDataTable(_ref2) {\n  var table = _ref2.table,\n      delimiters = _ref2.delimiters;\n  var rows = parseRows({\n    table: table,\n    delimiter: rowDelimiter\n  }).map(function (row) {\n    return parseCells({\n      row: row,\n      delimiter: cellDelimiter\n    });\n  });\n  var dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows)\n  };\n  return dataTable;\n};\nexport var getColumnNames = function getColumnNames(rows) {\n  return rows[0];\n};\nexport var getData = function getData(rows) {\n  return rows.slice(1);\n};\nexport var parseRows = function parseRows(_ref3) {\n  var table = _ref3.table,\n      delimiter = _ref3.delimiter;\n  return table.split(delimiter);\n};\nexport var parseCells = function parseCells(_ref4) {\n  var row = _ref4.row,\n      delimiter = _ref4.delimiter;\n  return row.split(delimiter);\n};","map":{"version":3,"sources":["/Volumes/GithubWorkspace/datatable-translatable/src/components/datatable/helpers.js"],"names":["parseDataTables","original","translation","compositeKeyIndices","delimiters","data","originalDataTable","parseDataTable","table","translationDataTable","columnNames","length","rowIndex","forEach","row","componsiteKey","map","index","join","Object","values","_row","originalCell","translationCell","rows","parseRows","delimiter","rowDelimiter","parseCells","cellDelimiter","dataTable","getColumnNames","getData","slice","split"],"mappings":"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","sourcesContent":["\n\nexport const parseDataTables = ({original, translation, compositeKeyIndices, delimiters}) => {\n  let data = [];\n  const originalDataTable = parseDataTable({table: original, delimiters});\n  const translationDataTable = parseDataTable({table: translation, delimiters})\n  if (originalDataTable.columnNames.length === translationDataTable.columnNames.length) {\n    let rowIndex = {};\n    originalDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { original: row };\n    });\n    translationDataTable.data.forEach(row => {\n      const componsiteKey = compositeKeyIndices.map(index => row[index]).join(':');\n      rowIndex[componsiteKey] = { translation: row, ...rowIndex[componsiteKey]};\n    });\n\n    data = Object.values(rowIndex).map(row => {\n      const _row = row.original.map((originalCell, index) => {\n        const translationCell = row.translation[index];\n        return `${originalCell}\\t${translationCell}`;\n      });\n      return _row;\n    });\n  }\n  return {\n    columnNames: originalDataTable.columnNames,\n    data,\n  };\n}\n\nexport const parseDataTable = ({table, delimiters}) => {\n  const rows = parseRows({table, delimiter: rowDelimiter})\n  .map(row =>\n    parseCells({row, delimiter: cellDelimiter})\n  );\n  const dataTable = {\n    columnNames: getColumnNames(rows),\n    data: getData(rows),\n  }\n  return dataTable;\n};\n\nexport const getColumnNames = (rows) => rows[0];\nexport const getData = (rows) => rows.slice(1);\n\nexport const parseRows = ({table, delimiter}) => table.split(delimiter);\nexport const parseCells = ({row, delimiter}) => row.split(delimiter);"]},"metadata":{},"sourceType":"module"}