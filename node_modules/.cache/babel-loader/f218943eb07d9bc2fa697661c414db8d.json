{"ast":null,"code":"function extend(destination) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) destination[key] = source[key];\n    }\n  }\n\n  return destination;\n}\n\nfunction repeat(character, count) {\n  return Array(count + 1).join(character);\n}\n\nvar blockElements = ['address', 'article', 'aside', 'audio', 'blockquote', 'body', 'canvas', 'center', 'dd', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'html', 'isindex', 'li', 'main', 'menu', 'nav', 'noframes', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];\n\nfunction isBlock(node) {\n  return blockElements.indexOf(node.nodeName.toLowerCase()) !== -1;\n}\n\nvar voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\nfunction isVoid(node) {\n  return voidElements.indexOf(node.nodeName.toLowerCase()) !== -1;\n}\n\nvar voidSelector = voidElements.join();\n\nfunction hasVoid(node) {\n  return node.querySelector && node.querySelector(voidSelector);\n}\n\nvar rules = {};\nrules.paragraph = {\n  filter: 'p',\n  replacement: function replacement(content) {\n    return '\\n\\n' + content + '\\n\\n';\n  }\n};\nrules.lineBreak = {\n  filter: 'br',\n  replacement: function replacement(content, node, options) {\n    return options.br + '\\n';\n  }\n};\nrules.heading = {\n  filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n  replacement: function replacement(content, node, options) {\n    var hLevel = Number(node.nodeName.charAt(1));\n\n    if (options.headingStyle === 'setext' && hLevel < 3) {\n      var underline = repeat(hLevel === 1 ? '=' : '-', content.length);\n      return '\\n\\n' + content + '\\n' + underline + '\\n\\n';\n    } else {\n      return '\\n\\n' + repeat('#', hLevel) + ' ' + content + '\\n\\n';\n    }\n  }\n};\nrules.blockquote = {\n  filter: 'blockquote',\n  replacement: function replacement(content) {\n    content = content.replace(/^\\n+|\\n+$/g, '');\n    content = content.replace(/^/gm, '> ');\n    return '\\n\\n' + content + '\\n\\n';\n  }\n};\nrules.list = {\n  filter: ['ul', 'ol'],\n  replacement: function replacement(content, node) {\n    var parent = node.parentNode;\n\n    if (parent.nodeName === 'LI' && parent.lastElementChild === node) {\n      return '\\n' + content;\n    } else {\n      return '\\n\\n' + content + '\\n\\n';\n    }\n  }\n};\nrules.listItem = {\n  filter: 'li',\n  replacement: function replacement(content, node, options) {\n    content = content.replace(/^\\n+/, '') // remove leading newlines\n    .replace(/\\n+$/, '\\n') // replace trailing newlines with just a single one\n    .replace(/\\n/gm, '\\n    '); // indent\n\n    var prefix = options.bulletListMarker + '   ';\n    var parent = node.parentNode;\n\n    if (parent.nodeName === 'OL') {\n      var start = parent.getAttribute('start');\n      var index = Array.prototype.indexOf.call(parent.children, node);\n      prefix = (start ? Number(start) + index : index + 1) + '.  ';\n    }\n\n    return prefix + content + (node.nextSibling && !/\\n$/.test(content) ? '\\n' : '');\n  }\n};\nrules.indentedCodeBlock = {\n  filter: function filter(node, options) {\n    return options.codeBlockStyle === 'indented' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';\n  },\n  replacement: function replacement(content, node, options) {\n    return '\\n\\n    ' + node.firstChild.textContent.replace(/\\n/g, '\\n    ') + '\\n\\n';\n  }\n};\nrules.fencedCodeBlock = {\n  filter: function filter(node, options) {\n    return options.codeBlockStyle === 'fenced' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';\n  },\n  replacement: function replacement(content, node, options) {\n    var className = node.firstChild.className || '';\n    var language = (className.match(/language-(\\S+)/) || [null, ''])[1];\n    return '\\n\\n' + options.fence + language + '\\n' + node.firstChild.textContent + '\\n' + options.fence + '\\n\\n';\n  }\n};\nrules.horizontalRule = {\n  filter: 'hr',\n  replacement: function replacement(content, node, options) {\n    return '\\n\\n' + options.hr + '\\n\\n';\n  }\n};\nrules.inlineLink = {\n  filter: function filter(node, options) {\n    return options.linkStyle === 'inlined' && node.nodeName === 'A' && node.getAttribute('href');\n  },\n  replacement: function replacement(content, node) {\n    var href = node.getAttribute('href');\n    var title = node.title ? ' \"' + node.title + '\"' : '';\n    return '[' + content + '](' + href + title + ')';\n  }\n};\nrules.referenceLink = {\n  filter: function filter(node, options) {\n    return options.linkStyle === 'referenced' && node.nodeName === 'A' && node.getAttribute('href');\n  },\n  replacement: function replacement(content, node, options) {\n    var href = node.getAttribute('href');\n    var title = node.title ? ' \"' + node.title + '\"' : '';\n    var replacement;\n    var reference;\n\n    switch (options.linkReferenceStyle) {\n      case 'collapsed':\n        replacement = '[' + content + '][]';\n        reference = '[' + content + ']: ' + href + title;\n        break;\n\n      case 'shortcut':\n        replacement = '[' + content + ']';\n        reference = '[' + content + ']: ' + href + title;\n        break;\n\n      default:\n        var id = this.references.length + 1;\n        replacement = '[' + content + '][' + id + ']';\n        reference = '[' + id + ']: ' + href + title;\n    }\n\n    this.references.push(reference);\n    return replacement;\n  },\n  references: [],\n  append: function append(options) {\n    var references = '';\n\n    if (this.references.length) {\n      references = '\\n\\n' + this.references.join('\\n') + '\\n\\n';\n      this.references = []; // Reset references\n    }\n\n    return references;\n  }\n};\nrules.emphasis = {\n  filter: ['em', 'i'],\n  replacement: function replacement(content, node, options) {\n    if (!content.trim()) return '';\n    return options.emDelimiter + content + options.emDelimiter;\n  }\n};\nrules.strong = {\n  filter: ['strong', 'b'],\n  replacement: function replacement(content, node, options) {\n    if (!content.trim()) return '';\n    return options.strongDelimiter + content + options.strongDelimiter;\n  }\n};\nrules.code = {\n  filter: function filter(node) {\n    var hasSiblings = node.previousSibling || node.nextSibling;\n    var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;\n    return node.nodeName === 'CODE' && !isCodeBlock;\n  },\n  replacement: function replacement(content) {\n    if (!content.trim()) return '';\n    var delimiter = '`';\n    var leadingSpace = '';\n    var trailingSpace = '';\n    var matches = content.match(/`+/gm);\n\n    if (matches) {\n      if (/^`/.test(content)) leadingSpace = ' ';\n      if (/`$/.test(content)) trailingSpace = ' ';\n\n      while (matches.indexOf(delimiter) !== -1) {\n        delimiter = delimiter + '`';\n      }\n    }\n\n    return delimiter + leadingSpace + content + trailingSpace + delimiter;\n  }\n};\nrules.image = {\n  filter: 'img',\n  replacement: function replacement(content, node) {\n    var alt = node.alt || '';\n    var src = node.getAttribute('src') || '';\n    var title = node.title || '';\n    var titlePart = title ? ' \"' + title + '\"' : '';\n    return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : '';\n  }\n};\n/**\n * Manages a collection of rules used to convert HTML to Markdown\n */\n\nfunction Rules(options) {\n  this.options = options;\n  this._keep = [];\n  this._remove = [];\n  this.blankRule = {\n    replacement: options.blankReplacement\n  };\n  this.keepReplacement = options.keepReplacement;\n  this.defaultRule = {\n    replacement: options.defaultReplacement\n  };\n  this.array = [];\n\n  for (var key in options.rules) {\n    this.array.push(options.rules[key]);\n  }\n}\n\nRules.prototype = {\n  add: function add(key, rule) {\n    this.array.unshift(rule);\n  },\n  keep: function keep(filter) {\n    this._keep.unshift({\n      filter: filter,\n      replacement: this.keepReplacement\n    });\n  },\n  remove: function remove(filter) {\n    this._remove.unshift({\n      filter: filter,\n      replacement: function replacement() {\n        return '';\n      }\n    });\n  },\n  forNode: function forNode(node) {\n    if (node.isBlank) return this.blankRule;\n    var rule;\n    if (rule = findRule(this.array, node, this.options)) return rule;\n    if (rule = findRule(this._keep, node, this.options)) return rule;\n    if (rule = findRule(this._remove, node, this.options)) return rule;\n    return this.defaultRule;\n  },\n  forEach: function forEach(fn) {\n    for (var i = 0; i < this.array.length; i++) {\n      fn(this.array[i], i);\n    }\n  }\n};\n\nfunction findRule(rules, node, options) {\n  for (var i = 0; i < rules.length; i++) {\n    var rule = rules[i];\n    if (filterValue(rule, node, options)) return rule;\n  }\n\n  return void 0;\n}\n\nfunction filterValue(rule, node, options) {\n  var filter = rule.filter;\n\n  if (typeof filter === 'string') {\n    if (filter === node.nodeName.toLowerCase()) return true;\n  } else if (Array.isArray(filter)) {\n    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;\n  } else if (typeof filter === 'function') {\n    if (filter.call(rule, node, options)) return true;\n  } else {\n    throw new TypeError('`filter` needs to be a string, array, or function');\n  }\n}\n/**\n * The collapseWhitespace function is adapted from collapse-whitespace\n * by Luc Thevenard.\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * collapseWhitespace(options) removes extraneous whitespace from an the given element.\n *\n * @param {Object} options\n */\n\n\nfunction collapseWhitespace(options) {\n  var element = options.element;\n  var isBlock = options.isBlock;\n  var isVoid = options.isVoid;\n\n  var isPre = options.isPre || function (node) {\n    return node.nodeName === 'PRE';\n  };\n\n  if (!element.firstChild || isPre(element)) return;\n  var prevText = null;\n  var prevVoid = false;\n  var prev = null;\n  var node = next(prev, element, isPre);\n\n  while (node !== element) {\n    if (node.nodeType === 3 || node.nodeType === 4) {\n      // Node.TEXT_NODE or Node.CDATA_SECTION_NODE\n      var text = node.data.replace(/[ \\r\\n\\t]+/g, ' ');\n\n      if ((!prevText || / $/.test(prevText.data)) && !prevVoid && text[0] === ' ') {\n        text = text.substr(1);\n      } // `text` might be empty at this point.\n\n\n      if (!text) {\n        node = remove(node);\n        continue;\n      }\n\n      node.data = text;\n      prevText = node;\n    } else if (node.nodeType === 1) {\n      // Node.ELEMENT_NODE\n      if (isBlock(node) || node.nodeName === 'BR') {\n        if (prevText) {\n          prevText.data = prevText.data.replace(/ $/, '');\n        }\n\n        prevText = null;\n        prevVoid = false;\n      } else if (isVoid(node)) {\n        // Avoid trimming space around non-block, non-BR void elements.\n        prevText = null;\n        prevVoid = true;\n      }\n    } else {\n      node = remove(node);\n      continue;\n    }\n\n    var nextNode = next(prev, node, isPre);\n    prev = node;\n    node = nextNode;\n  }\n\n  if (prevText) {\n    prevText.data = prevText.data.replace(/ $/, '');\n\n    if (!prevText.data) {\n      remove(prevText);\n    }\n  }\n}\n/**\n * remove(node) removes the given node from the DOM and returns the\n * next node in the sequence.\n *\n * @param {Node} node\n * @return {Node} node\n */\n\n\nfunction remove(node) {\n  var next = node.nextSibling || node.parentNode;\n  node.parentNode.removeChild(node);\n  return next;\n}\n/**\n * next(prev, current, isPre) returns the next node in the sequence, given the\n * current and previous nodes.\n *\n * @param {Node} prev\n * @param {Node} current\n * @param {Function} isPre\n * @return {Node}\n */\n\n\nfunction next(prev, current, isPre) {\n  if (prev && prev.parentNode === current || isPre(current)) {\n    return current.nextSibling || current.parentNode;\n  }\n\n  return current.firstChild || current.nextSibling || current.parentNode;\n}\n/*\n * Set up window for Node.js\n */\n\n\nvar root = typeof window !== 'undefined' ? window : {};\n/*\n * Parsing HTML strings\n */\n\nfunction canParseHTMLNatively() {\n  var Parser = root.DOMParser;\n  var canParse = false; // Adapted from https://gist.github.com/1129031\n  // Firefox/Opera/IE throw errors on unsupported types\n\n  try {\n    // WebKit returns null on unsupported types\n    if (new Parser().parseFromString('', 'text/html')) {\n      canParse = true;\n    }\n  } catch (e) {}\n\n  return canParse;\n}\n\nfunction createHTMLParser() {\n  var Parser = function Parser() {};\n\n  {\n    var JSDOM = require('jsdom').JSDOM;\n\n    Parser.prototype.parseFromString = function (string) {\n      return new JSDOM(string).window.document;\n    };\n  }\n  return Parser;\n}\n\nvar HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();\n\nfunction RootNode(input) {\n  var root;\n\n  if (typeof input === 'string') {\n    var doc = htmlParser().parseFromString( // DOM parsers arrange elements in the <head> and <body>.\n    // Wrapping in a custom element ensures elements are reliably arranged in\n    // a single element.\n    '<x-turndown id=\"turndown-root\">' + input + '</x-turndown>', 'text/html');\n    root = doc.getElementById('turndown-root');\n  } else {\n    root = input.cloneNode(true);\n  }\n\n  collapseWhitespace({\n    element: root,\n    isBlock: isBlock,\n    isVoid: isVoid\n  });\n  return root;\n}\n\nvar _htmlParser;\n\nfunction htmlParser() {\n  _htmlParser = _htmlParser || new HTMLParser();\n  return _htmlParser;\n}\n\nfunction Node(node) {\n  node.isBlock = isBlock(node);\n  node.isCode = node.nodeName.toLowerCase() === 'code' || node.parentNode.isCode;\n  node.isBlank = isBlank(node);\n  node.flankingWhitespace = flankingWhitespace(node);\n  return node;\n}\n\nfunction isBlank(node) {\n  return ['A', 'TH', 'TD', 'IFRAME', 'SCRIPT', 'AUDIO', 'VIDEO'].indexOf(node.nodeName) === -1 && /^\\s*$/i.test(node.textContent) && !isVoid(node) && !hasVoid(node);\n}\n\nfunction flankingWhitespace(node) {\n  var leading = '';\n  var trailing = '';\n\n  if (!node.isBlock) {\n    var hasLeading = /^[ \\r\\n\\t]/.test(node.textContent);\n    var hasTrailing = /[ \\r\\n\\t]$/.test(node.textContent);\n\n    if (hasLeading && !isFlankedByWhitespace('left', node)) {\n      leading = ' ';\n    }\n\n    if (hasTrailing && !isFlankedByWhitespace('right', node)) {\n      trailing = ' ';\n    }\n  }\n\n  return {\n    leading: leading,\n    trailing: trailing\n  };\n}\n\nfunction isFlankedByWhitespace(side, node) {\n  var sibling;\n  var regExp;\n  var isFlanked;\n\n  if (side === 'left') {\n    sibling = node.previousSibling;\n    regExp = / $/;\n  } else {\n    sibling = node.nextSibling;\n    regExp = /^ /;\n  }\n\n  if (sibling) {\n    if (sibling.nodeType === 3) {\n      isFlanked = regExp.test(sibling.nodeValue);\n    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\n      isFlanked = regExp.test(sibling.textContent);\n    }\n  }\n\n  return isFlanked;\n}\n\nvar reduce = Array.prototype.reduce;\nvar leadingNewLinesRegExp = /^\\n*/;\nvar trailingNewLinesRegExp = /\\n*$/;\nvar escapes = [[/\\\\/g, '\\\\\\\\'], [/\\*/g, '\\\\*'], [/^-/g, '\\\\-'], [/^\\+ /g, '\\\\+ '], [/^(=+)/g, '\\\\$1'], [/^(#{1,6}) /g, '\\\\$1 '], [/`/g, '\\\\`'], [/^~~~/g, '\\\\~~~'], [/\\[/g, '\\\\['], [/\\]/g, '\\\\]'], [/^>/g, '\\\\>'], [/_/g, '\\\\_'], [/^(\\d+)\\. /g, '$1\\\\. ']];\n\nfunction TurndownService(options) {\n  if (!(this instanceof TurndownService)) return new TurndownService(options);\n  var defaults = {\n    rules: rules,\n    headingStyle: 'setext',\n    hr: '* * *',\n    bulletListMarker: '*',\n    codeBlockStyle: 'indented',\n    fence: '```',\n    emDelimiter: '_',\n    strongDelimiter: '**',\n    linkStyle: 'inlined',\n    linkReferenceStyle: 'full',\n    br: '  ',\n    blankReplacement: function blankReplacement(content, node) {\n      return node.isBlock ? '\\n\\n' : '';\n    },\n    keepReplacement: function keepReplacement(content, node) {\n      return node.isBlock ? '\\n\\n' + node.outerHTML + '\\n\\n' : node.outerHTML;\n    },\n    defaultReplacement: function defaultReplacement(content, node) {\n      return node.isBlock ? '\\n\\n' + content + '\\n\\n' : content;\n    }\n  };\n  this.options = extend({}, defaults, options);\n  this.rules = new Rules(this.options);\n}\n\nTurndownService.prototype = {\n  /**\n   * The entry point for converting a string or DOM node to Markdown\n   * @public\n   * @param {String|HTMLElement} input The string or DOM node to convert\n   * @returns A Markdown representation of the input\n   * @type String\n   */\n  turndown: function turndown(input) {\n    if (!canConvert(input)) {\n      throw new TypeError(input + ' is not a string, or an element/document/fragment node.');\n    }\n\n    if (input === '') return '';\n    var output = process.call(this, new RootNode(input));\n    return postProcess.call(this, output);\n  },\n\n  /**\n   * Add one or more plugins\n   * @public\n   * @param {Function|Array} plugin The plugin or array of plugins to add\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n  use: function use(plugin) {\n    if (Array.isArray(plugin)) {\n      for (var i = 0; i < plugin.length; i++) {\n        this.use(plugin[i]);\n      }\n    } else if (typeof plugin === 'function') {\n      plugin(this);\n    } else {\n      throw new TypeError('plugin must be a Function or an Array of Functions');\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds a rule\n   * @public\n   * @param {String} key The unique key of the rule\n   * @param {Object} rule The rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n  addRule: function addRule(key, rule) {\n    this.rules.add(key, rule);\n    return this;\n  },\n\n  /**\n   * Keep a node (as HTML) that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n  keep: function keep(filter) {\n    this.rules.keep(filter);\n    return this;\n  },\n\n  /**\n   * Remove a node that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n  remove: function remove(filter) {\n    this.rules.remove(filter);\n    return this;\n  },\n\n  /**\n   * Escapes Markdown syntax\n   * @public\n   * @param {String} string The string to escape\n   * @returns A string with Markdown syntax escaped\n   * @type String\n   */\n  escape: function escape(string) {\n    return escapes.reduce(function (accumulator, escape) {\n      return accumulator.replace(escape[0], escape[1]);\n    }, string);\n  }\n};\n/**\n * Reduces a DOM node down to its Markdown string equivalent\n * @private\n * @param {HTMLElement} parentNode The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\nfunction process(parentNode) {\n  var self = this;\n  return reduce.call(parentNode.childNodes, function (output, node) {\n    node = new Node(node);\n    var replacement = '';\n\n    if (node.nodeType === 3) {\n      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);\n    } else if (node.nodeType === 1) {\n      replacement = replacementForNode.call(self, node);\n    }\n\n    return join(output, replacement);\n  }, '');\n}\n/**\n * Appends strings as each rule requires and trims the output\n * @private\n * @param {String} output The conversion output\n * @returns A trimmed version of the ouput\n * @type String\n */\n\n\nfunction postProcess(output) {\n  var self = this;\n  this.rules.forEach(function (rule) {\n    if (typeof rule.append === 'function') {\n      output = join(output, rule.append(self.options));\n    }\n  });\n  return output.replace(/^[\\t\\r\\n]+/, '').replace(/[\\t\\r\\n\\s]+$/, '');\n}\n/**\n * Converts an element node to its Markdown equivalent\n * @private\n * @param {HTMLElement} node The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\n\nfunction replacementForNode(node) {\n  var rule = this.rules.forNode(node);\n  var content = process.call(this, node);\n  var whitespace = node.flankingWhitespace;\n  if (whitespace.leading || whitespace.trailing) content = content.trim();\n  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;\n}\n/**\n * Determines the new lines between the current output and the replacement\n * @private\n * @param {String} output The current conversion output\n * @param {String} replacement The string to append to the output\n * @returns The whitespace to separate the current output and the replacement\n * @type String\n */\n\n\nfunction separatingNewlines(output, replacement) {\n  var newlines = [output.match(trailingNewLinesRegExp)[0], replacement.match(leadingNewLinesRegExp)[0]].sort();\n  var maxNewlines = newlines[newlines.length - 1];\n  return maxNewlines.length < 2 ? maxNewlines : '\\n\\n';\n}\n\nfunction join(string1, string2) {\n  var separator = separatingNewlines(string1, string2); // Remove trailing/leading newlines and replace with separator\n\n  string1 = string1.replace(trailingNewLinesRegExp, '');\n  string2 = string2.replace(leadingNewLinesRegExp, '');\n  return string1 + separator + string2;\n}\n/**\n * Determines whether an input can be converted\n * @private\n * @param {String|HTMLElement} input Describe this parameter\n * @returns Describe what it returns\n * @type String|Object|Array|Boolean|Number\n */\n\n\nfunction canConvert(input) {\n  return input != null && (typeof input === 'string' || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));\n}\n\nexport default TurndownService;","map":null,"metadata":{},"sourceType":"module"}