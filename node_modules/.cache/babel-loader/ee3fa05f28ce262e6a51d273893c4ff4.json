{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styles = require(\"@material-ui/core/styles\");\n\nvar _reactMarkdown = _interopRequireDefault(require(\"react-markdown\"));\n\nvar _md = _interopRequireDefault(require(\"md5\"));\n\nvar _core = require(\"@material-ui/core\");\n\nvar _icons = require(\"@material-ui/icons\");\n\nvar _blockTranslatable = _interopRequireDefault(require(\"../block-translatable\"));\n\nvar helpers = _interopRequireWildcard(require(\"./helpers\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n} // const whyDidYouRender = (process.env.NODE_ENV !== 'production') ?\n//   require('@welldone-software/why-did-you-render') : undefined;\n// if (whyDidYouRender) whyDidYouRender(React);\n\n/**\n * ### A reusable component for translating Markdown in sections.\n * @component\n */\n\n\nfunction SectionTranslatable(_ref) {\n  var classes = _ref.classes,\n      original = _ref.original,\n      translation = _ref.translation,\n      inputFilters = _ref.inputFilters,\n      outputFilters = _ref.outputFilters,\n      onTranslation = _ref.onTranslation,\n      onSectionFocus = _ref.onSectionFocus,\n      sectionFocus = _ref.sectionFocus,\n      style = _ref.style;\n\n  var _useState = (0, _react.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      raw = _useState2[0],\n      setRaw = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(sectionFocus),\n      _useState4 = _slicedToArray(_useState3, 2),\n      expanded = _useState4[0],\n      setExpanded = _useState4[1];\n\n  var originalBlocks = helpers.blocksFromMarkdown({\n    markdown: original\n  });\n\n  var __translationBlocks = helpers.blocksFromMarkdown({\n    markdown: translation\n  });\n\n  var _useState5 = (0, _react.useState)(__translationBlocks),\n      _useState6 = _slicedToArray(_useState5, 2),\n      translationBlocks = _useState6[0],\n      setTranslationBlocks = _useState6[1];\n\n  var _useState7 = (0, _react.useState)(),\n      _useState8 = _slicedToArray(_useState7, 2),\n      editedTranslation = _useState8[0],\n      setEditedTranslation = _useState8[1];\n\n  var saveEditedTranslation = function saveEditedTranslation() {\n    return onTranslation(editedTranslation);\n  };\n\n  var toggleRaw = function toggleRaw() {\n    return setRaw(!raw);\n  };\n\n  if (onSectionFocus && sectionFocus !== expanded) setExpanded(sectionFocus);\n\n  var expandedToggle = function expandedToggle() {\n    var _expanded = !expanded;\n\n    if (onSectionFocus) onSectionFocus(_expanded);\n    setExpanded(_expanded);\n  };\n\n  var setTranslationBlock = function setTranslationBlock(_ref2) {\n    var index = _ref2.index,\n        translationBlock = _ref2.translationBlock;\n\n    var _translationBlocks = _toConsumableArray(translationBlocks);\n\n    _translationBlocks[index] = translationBlock;\n    setTranslationBlocks(_translationBlocks);\n\n    var _translation = helpers.markdownFromBlocks({\n      blocks: _translationBlocks\n    });\n\n    setEditedTranslation(_translation);\n  };\n\n  var blockTranslatables = originalBlocks.map(function (originalBlock, index) {\n    var key = index + (0, _md[\"default\"])(JSON.stringify(originalBlock));\n\n    var _onTranslation = function _onTranslation(translationBlock) {\n      return setTranslationBlock({\n        index: index,\n        translationBlock: translationBlock\n      });\n    };\n\n    var translationBlock = translationBlocks[index];\n    return _react[\"default\"].createElement(_blockTranslatable[\"default\"], {\n      key: key,\n      original: originalBlock,\n      translation: translationBlock,\n      inputFilters: inputFilters,\n      outputFilters: outputFilters,\n      onTranslation: _onTranslation,\n      raw: raw\n    });\n  });\n  var titleBlock = originalBlocks[0];\n  var summaryTitle = expanded ? _react[\"default\"].createElement(_react[\"default\"].Fragment, null) : _react[\"default\"].createElement(_reactMarkdown[\"default\"], {\n    source: titleBlock,\n    escapeHtml: false\n  });\n  var changed = editedTranslation && translation !== editedTranslation;\n  var saveIcon = changed ? _react[\"default\"].createElement(_icons.Save, null) : _react[\"default\"].createElement(_icons.SaveOutlined, null);\n  var rawIcon = raw ? _react[\"default\"].createElement(_icons.Pageview, null) : _react[\"default\"].createElement(_icons.PageviewOutlined, null);\n  return _react[\"default\"].createElement(_core.ExpansionPanel, {\n    style: style,\n    className: classes.root,\n    expanded: expanded\n  }, _react[\"default\"].createElement(_core.ExpansionPanelSummary, {\n    expandIcon: _react[\"default\"].createElement(_icons.ExpandMore, null) // classes={{content: 'summaryContent'}}\n    ,\n    className: classes.content,\n    onClick: expandedToggle,\n    children: summaryTitle\n  }), _react[\"default\"].createElement(_core.ExpansionPanelDetails, {\n    className: classes.details\n  }, blockTranslatables), _react[\"default\"].createElement(_core.ExpansionPanelActions, {\n    className: classes.actions\n  }, _react[\"default\"].createElement(_core.IconButton, {\n    onClick: toggleRaw\n  }, rawIcon), _react[\"default\"].createElement(_core.IconButton, {\n    disabled: !changed,\n    onClick: saveEditedTranslation\n  }, saveIcon), _react[\"default\"].createElement(_core.IconButton, {\n    onClick: expandedToggle\n  }, _react[\"default\"].createElement(_icons.ExpandLess, null))));\n}\n\n;\nSectionTranslatable.propTypes = {\n  /** Original markdown for the editor. */\n  original: _propTypes[\"default\"].string.isRequired,\n\n  /** Translation markdown for the editor. */\n  translation: _propTypes[\"default\"].string.isRequired,\n\n  /** Function to propogate changes to the translation. */\n  onTranslation: _propTypes[\"default\"].func.isRequired,\n\n  /** Function to propogate changes to the Section in focus. */\n  onSectionFocus: _propTypes[\"default\"].func,\n\n  /** Set the Section in focus. */\n  sectionFocus: _propTypes[\"default\"].bool,\n\n  /** Replace strings before rendering. */\n  inputFilters: _propTypes[\"default\"].array,\n\n  /** Replace strings after editing. */\n  outputFilters: _propTypes[\"default\"].array,\n\n  /** CSS for the component. */\n  style: _propTypes[\"default\"].object\n};\nSectionTranslatable.defaultProps = {\n  original: '',\n  translation: '',\n  inputFilters: [],\n  outputFilters: [],\n  sectionFocus: false,\n  style: {}\n};\n\nvar styles = function styles(theme) {\n  return {\n    root: {},\n    details: {\n      display: 'block',\n      padding: '0',\n      borderTop: '1px solid #ccc',\n      borderBottom: '1px solid #ccc'\n    },\n    actions: {\n      padding: '8px'\n    }\n  };\n};\n\nvar areEqual = function areEqual(prevProps, nextProps) {\n  var keys = ['original', 'translation', 'sectionFocus', 'style'];\n  var checks = keys.map(function (key) {\n    return JSON.stringify(prevProps[key]) === JSON.stringify(nextProps[key]);\n  });\n  var equal = !checks.includes(false); // console.log('SectionTranslatable', keys, checks, equal);\n\n  return equal;\n}; // SectionTranslatable.whyDidYouRender = true;\n\n\nvar StyleComponent = (0, _styles.withStyles)(styles)(SectionTranslatable);\n\nvar MemoComponent = _react[\"default\"].memo(StyleComponent, areEqual);\n\nvar _default = MemoComponent;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}