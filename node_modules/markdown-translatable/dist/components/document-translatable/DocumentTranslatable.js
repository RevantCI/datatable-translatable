"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _styles = require("@material-ui/core/styles");

var _md = _interopRequireDefault(require("md5"));

var _sectionTranslatable = _interopRequireDefault(require("../section-translatable"));

var helpers = _interopRequireWildcard(require("./helpers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// const whyDidYouRender = (process.env.NODE_ENV !== 'production') ?
//   require('@welldone-software/why-did-you-render') : undefined;
// if (whyDidYouRender) whyDidYouRender(React);

/**
 * ### A reusable component for translating a Markdown document.
 * @component
 */
function DocumentTranslatable(_ref) {
  var classes = _ref.classes,
      original = _ref.original,
      translation = _ref.translation,
      inputFilters = _ref.inputFilters,
      outputFilters = _ref.outputFilters,
      onTranslation = _ref.onTranslation,
      style = _ref.style;

  var _useState = (0, _react.useState)(0),
      _useState2 = _slicedToArray(_useState, 2),
      sectionFocus = _useState2[0],
      setSectionFocus = _useState2[1];

  var originalSections = helpers.sectionsFromMarkdown({
    markdown: original
  });

  var __translationSections = helpers.sectionsFromMarkdown({
    markdown: translation
  });

  var _useState3 = (0, _react.useState)(__translationSections),
      _useState4 = _slicedToArray(_useState3, 2),
      translationSections = _useState4[0],
      setTranslationSections = _useState4[1];

  var setTranslationSection = function setTranslationSection(_ref2) {
    var index = _ref2.index,
        translationSection = _ref2.translationSection;
    setSectionFocus(index);

    var _translationSections = _toConsumableArray(translationSections);

    _translationSections[index] = translationSection;
    setTranslationSections(_translationSections);

    var _translation = helpers.markdownFromSections({
      sections: _translationSections
    });

    onTranslation(_translation);
  };

  var sectionTranslatables = originalSections.map(function (originalSection, index) {
    var key = index + (0, _md.default)(JSON.stringify(originalSection));
    var translationSection = translationSections[index];

    var _onTranslation = function _onTranslation(_translationSection) {
      return setTranslationSection({
        index: index,
        translationSection: _translationSection
      });
    };

    var _onSectionFocus = function _onSectionFocus(expanded) {
      if (expanded) setSectionFocus(index);else setSectionFocus(null);
    };

    var _sectionFocus = sectionFocus === index;

    return _react.default.createElement(_sectionTranslatable.default, {
      key: key,
      original: originalSection,
      translation: translationSection,
      inputFilters: inputFilters,
      outputFilters: outputFilters,
      onTranslation: _onTranslation,
      onSectionFocus: _onSectionFocus,
      sectionFocus: _sectionFocus,
      style: style
    });
  });
  return _react.default.createElement(_react.default.Fragment, null, sectionTranslatables);
}

;
DocumentTranslatable.propTypes = {
  /** Original markdown for the editor. */
  original: _propTypes.default.string.isRequired,

  /** Translation markdown for the editor. */
  translation: _propTypes.default.string.isRequired,

  /** Function to propogate changes to the translation. */
  onTranslation: _propTypes.default.func.isRequired,

  /** Replace strings before rendering. */
  inputFilters: _propTypes.default.array,

  /** Replace strings after editing. */
  outputFilters: _propTypes.default.array,

  /** CSS for the component. */
  style: _propTypes.default.object
};
DocumentTranslatable.defaultProps = {
  original: '',
  translation: '',
  onTranslation: function onTranslation() {},
  inputFilters: [],
  outputFilters: [],
  style: {}
};

var styles = function styles(theme) {
  return {
    root: {},
    details: {
      display: 'block',
      padding: '0',
      borderTop: '1px solid #ccc',
      borderBottom: '1px solid #ccc'
    }
  };
};

var areEqual = function areEqual(prevProps, nextProps) {
  var keys = ['original', 'translation', 'style'];
  var checks = keys.map(function (key) {
    return JSON.stringify(prevProps[key]) === JSON.stringify(nextProps[key]);
  });
  var equal = !checks.includes(false); // console.log('DocumentTranslatable', keys, checks, equal);

  return equal;
}; // DocumentTranslatable.whyDidYouRender = true;


var StyleComponent = (0, _styles.withStyles)(styles)(DocumentTranslatable);

var MemoComponent = _react.default.memo(StyleComponent, areEqual);

var _default = MemoComponent;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2RvY3VtZW50LXRyYW5zbGF0YWJsZS9Eb2N1bWVudFRyYW5zbGF0YWJsZS5qcyJdLCJuYW1lcyI6WyJEb2N1bWVudFRyYW5zbGF0YWJsZSIsImNsYXNzZXMiLCJvcmlnaW5hbCIsInRyYW5zbGF0aW9uIiwiaW5wdXRGaWx0ZXJzIiwib3V0cHV0RmlsdGVycyIsIm9uVHJhbnNsYXRpb24iLCJzdHlsZSIsInNlY3Rpb25Gb2N1cyIsInNldFNlY3Rpb25Gb2N1cyIsIm9yaWdpbmFsU2VjdGlvbnMiLCJoZWxwZXJzIiwic2VjdGlvbnNGcm9tTWFya2Rvd24iLCJtYXJrZG93biIsIl9fdHJhbnNsYXRpb25TZWN0aW9ucyIsInRyYW5zbGF0aW9uU2VjdGlvbnMiLCJzZXRUcmFuc2xhdGlvblNlY3Rpb25zIiwic2V0VHJhbnNsYXRpb25TZWN0aW9uIiwiaW5kZXgiLCJ0cmFuc2xhdGlvblNlY3Rpb24iLCJfdHJhbnNsYXRpb25TZWN0aW9ucyIsIl90cmFuc2xhdGlvbiIsIm1hcmtkb3duRnJvbVNlY3Rpb25zIiwic2VjdGlvbnMiLCJzZWN0aW9uVHJhbnNsYXRhYmxlcyIsIm1hcCIsIm9yaWdpbmFsU2VjdGlvbiIsImtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJfb25UcmFuc2xhdGlvbiIsIl90cmFuc2xhdGlvblNlY3Rpb24iLCJfb25TZWN0aW9uRm9jdXMiLCJleHBhbmRlZCIsIl9zZWN0aW9uRm9jdXMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiZnVuYyIsImFycmF5Iiwib2JqZWN0IiwiZGVmYXVsdFByb3BzIiwic3R5bGVzIiwidGhlbWUiLCJyb290IiwiZGV0YWlscyIsImRpc3BsYXkiLCJwYWRkaW5nIiwiYm9yZGVyVG9wIiwiYm9yZGVyQm90dG9tIiwiYXJlRXF1YWwiLCJwcmV2UHJvcHMiLCJuZXh0UHJvcHMiLCJrZXlzIiwiY2hlY2tzIiwiZXF1YWwiLCJpbmNsdWRl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QUFBQSxZQUFZLEVBQUU7QUFKUDtBQUhjLEdBQUw7QUFBQSxDQUFwQjs7QUFXQSxJQUFNQyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFDQyxTQUFELEVBQVlDLFNBQVosRUFBMEI7QUFDekMsTUFBTUMsSUFBSSxHQUFHLENBQUMsVUFBRCxFQUFhLGFBQWIsRUFBNEIsT0FBNUIsQ0FBYjtBQUNBLE1BQU1DLE1BQU0sR0FBR0QsSUFBSSxDQUFDN0IsR0FBTCxDQUFTLFVBQUFFLEdBQUc7QUFBQSxXQUFLQyxJQUFJLENBQUNDLFNBQUwsQ0FBZXVCLFNBQVMsQ0FBQ3pCLEdBQUQsQ0FBeEIsTUFBbUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFld0IsU0FBUyxDQUFDMUIsR0FBRCxDQUF4QixDQUF4QztBQUFBLEdBQVosQ0FBZjtBQUNBLE1BQU02QixLQUFLLEdBQUcsQ0FBQ0QsTUFBTSxDQUFDRSxRQUFQLENBQWdCLEtBQWhCLENBQWYsQ0FIeUMsQ0FJekM7O0FBQ0EsU0FBT0QsS0FBUDtBQUNELENBTkQsQyxDQVFBOzs7QUFDQSxJQUFNRSxjQUFjLEdBQUcsd0JBQVdmLE1BQVgsRUFBbUIzQyxvQkFBbkIsQ0FBdkI7O0FBQ0EsSUFBTTJELGFBQWEsR0FBR0MsZUFBTUMsSUFBTixDQUFXSCxjQUFYLEVBQTJCUCxRQUEzQixDQUF0Qjs7ZUFDZVEsYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge3VzZVN0YXRlfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgd2l0aFN0eWxlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcyc7XG5pbXBvcnQgbWQ1IGZyb20gJ21kNSc7XG5cbmltcG9ydCBTZWN0aW9uVHJhbnNsYXRhYmxlIGZyb20gJy4uL3NlY3Rpb24tdHJhbnNsYXRhYmxlJztcblxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMnO1xuXG4vLyBjb25zdCB3aHlEaWRZb3VSZW5kZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgP1xuLy8gICByZXF1aXJlKCdAd2VsbGRvbmUtc29mdHdhcmUvd2h5LWRpZC15b3UtcmVuZGVyJykgOiB1bmRlZmluZWQ7XG4vLyBpZiAod2h5RGlkWW91UmVuZGVyKSB3aHlEaWRZb3VSZW5kZXIoUmVhY3QpO1xuLyoqXG4gKiAjIyMgQSByZXVzYWJsZSBjb21wb25lbnQgZm9yIHRyYW5zbGF0aW5nIGEgTWFya2Rvd24gZG9jdW1lbnQuXG4gKiBAY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIERvY3VtZW50VHJhbnNsYXRhYmxlKHtcbiAgY2xhc3NlcyxcbiAgb3JpZ2luYWwsXG4gIHRyYW5zbGF0aW9uLFxuICBpbnB1dEZpbHRlcnMsXG4gIG91dHB1dEZpbHRlcnMsXG4gIG9uVHJhbnNsYXRpb24sXG4gIHN0eWxlLFxufSkge1xuICBjb25zdCBbc2VjdGlvbkZvY3VzLCBzZXRTZWN0aW9uRm9jdXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IG9yaWdpbmFsU2VjdGlvbnMgPSBoZWxwZXJzLnNlY3Rpb25zRnJvbU1hcmtkb3duKHttYXJrZG93bjogb3JpZ2luYWx9KTtcbiAgY29uc3QgX190cmFuc2xhdGlvblNlY3Rpb25zID0gaGVscGVycy5zZWN0aW9uc0Zyb21NYXJrZG93bih7bWFya2Rvd246IHRyYW5zbGF0aW9ufSk7XG4gIGNvbnN0IFt0cmFuc2xhdGlvblNlY3Rpb25zLCBzZXRUcmFuc2xhdGlvblNlY3Rpb25zXSA9IHVzZVN0YXRlKF9fdHJhbnNsYXRpb25TZWN0aW9ucyk7XG5cbiAgY29uc3Qgc2V0VHJhbnNsYXRpb25TZWN0aW9uID0gKHtpbmRleCwgdHJhbnNsYXRpb25TZWN0aW9ufSkgPT4ge1xuICAgIHNldFNlY3Rpb25Gb2N1cyhpbmRleCk7XG4gICAgbGV0IF90cmFuc2xhdGlvblNlY3Rpb25zID0gWy4uLnRyYW5zbGF0aW9uU2VjdGlvbnNdO1xuICAgIF90cmFuc2xhdGlvblNlY3Rpb25zW2luZGV4XSA9IHRyYW5zbGF0aW9uU2VjdGlvbjtcbiAgICBzZXRUcmFuc2xhdGlvblNlY3Rpb25zKF90cmFuc2xhdGlvblNlY3Rpb25zKTtcbiAgICBjb25zdCBfdHJhbnNsYXRpb24gPSBoZWxwZXJzLm1hcmtkb3duRnJvbVNlY3Rpb25zKHtzZWN0aW9uczogX3RyYW5zbGF0aW9uU2VjdGlvbnN9KTtcbiAgICBvblRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbik7XG4gIH07XG5cbiAgY29uc3Qgc2VjdGlvblRyYW5zbGF0YWJsZXMgPSBvcmlnaW5hbFNlY3Rpb25zLm1hcCgob3JpZ2luYWxTZWN0aW9uLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGluZGV4ICsgbWQ1KEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsU2VjdGlvbikpO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uU2VjdGlvbiA9IHRyYW5zbGF0aW9uU2VjdGlvbnNbaW5kZXhdO1xuICAgIGNvbnN0IF9vblRyYW5zbGF0aW9uID0gKF90cmFuc2xhdGlvblNlY3Rpb24pID0+XG4gICAgICBzZXRUcmFuc2xhdGlvblNlY3Rpb24oe2luZGV4LCB0cmFuc2xhdGlvblNlY3Rpb246IF90cmFuc2xhdGlvblNlY3Rpb259KTtcbiAgICBjb25zdCBfb25TZWN0aW9uRm9jdXMgPSAoZXhwYW5kZWQpID0+IHtcbiAgICAgIGlmIChleHBhbmRlZCkgc2V0U2VjdGlvbkZvY3VzKGluZGV4KTtcbiAgICAgIGVsc2Ugc2V0U2VjdGlvbkZvY3VzKG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgX3NlY3Rpb25Gb2N1cyA9IChzZWN0aW9uRm9jdXMgPT09IGluZGV4KVxuICAgIHJldHVybiAoXG4gICAgICA8U2VjdGlvblRyYW5zbGF0YWJsZVxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgb3JpZ2luYWw9e29yaWdpbmFsU2VjdGlvbn1cbiAgICAgICAgdHJhbnNsYXRpb249e3RyYW5zbGF0aW9uU2VjdGlvbn1cbiAgICAgICAgaW5wdXRGaWx0ZXJzPXtpbnB1dEZpbHRlcnN9XG4gICAgICAgIG91dHB1dEZpbHRlcnM9e291dHB1dEZpbHRlcnN9XG4gICAgICAgIG9uVHJhbnNsYXRpb249e19vblRyYW5zbGF0aW9ufVxuICAgICAgICBvblNlY3Rpb25Gb2N1cz17X29uU2VjdGlvbkZvY3VzfVxuICAgICAgICBzZWN0aW9uRm9jdXM9e19zZWN0aW9uRm9jdXN9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuICg8PntzZWN0aW9uVHJhbnNsYXRhYmxlc308Lz4pO1xufTtcblxuRG9jdW1lbnRUcmFuc2xhdGFibGUucHJvcFR5cGVzID0ge1xuICAvKiogT3JpZ2luYWwgbWFya2Rvd24gZm9yIHRoZSBlZGl0b3IuICovXG4gIG9yaWdpbmFsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIC8qKiBUcmFuc2xhdGlvbiBtYXJrZG93biBmb3IgdGhlIGVkaXRvci4gKi9cbiAgdHJhbnNsYXRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgLyoqIEZ1bmN0aW9uIHRvIHByb3BvZ2F0ZSBjaGFuZ2VzIHRvIHRoZSB0cmFuc2xhdGlvbi4gKi9cbiAgb25UcmFuc2xhdGlvbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgLyoqIFJlcGxhY2Ugc3RyaW5ncyBiZWZvcmUgcmVuZGVyaW5nLiAqL1xuICBpbnB1dEZpbHRlcnM6IFByb3BUeXBlcy5hcnJheSxcbiAgLyoqIFJlcGxhY2Ugc3RyaW5ncyBhZnRlciBlZGl0aW5nLiAqL1xuICBvdXRwdXRGaWx0ZXJzOiBQcm9wVHlwZXMuYXJyYXksXG4gIC8qKiBDU1MgZm9yIHRoZSBjb21wb25lbnQuICovXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxufTtcblxuRG9jdW1lbnRUcmFuc2xhdGFibGUuZGVmYXVsdFByb3BzID0ge1xuICBvcmlnaW5hbDogJycsXG4gIHRyYW5zbGF0aW9uOiAnJyxcbiAgb25UcmFuc2xhdGlvbjogKCkgPT4ge30sXG4gIGlucHV0RmlsdGVyczogW10sXG4gIG91dHB1dEZpbHRlcnM6IFtdLFxuICBzdHlsZToge30sXG59XG5cbmNvbnN0IHN0eWxlcyA9IHRoZW1lID0+ICh7XG4gIHJvb3Q6IHtcbiAgfSxcbiAgZGV0YWlsczoge1xuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgcGFkZGluZzogJzAnLFxuICAgIGJvcmRlclRvcDogJzFweCBzb2xpZCAjY2NjJyxcbiAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgI2NjYycsXG4gIH0sXG59KTtcblxuY29uc3QgYXJlRXF1YWwgPSAocHJldlByb3BzLCBuZXh0UHJvcHMpID0+IHtcbiAgY29uc3Qga2V5cyA9IFsnb3JpZ2luYWwnLCAndHJhbnNsYXRpb24nLCAnc3R5bGUnXTtcbiAgY29uc3QgY2hlY2tzID0ga2V5cy5tYXAoa2V5ID0+IChKU09OLnN0cmluZ2lmeShwcmV2UHJvcHNba2V5XSkgPT09IEpTT04uc3RyaW5naWZ5KG5leHRQcm9wc1trZXldKSkpO1xuICBjb25zdCBlcXVhbCA9ICFjaGVja3MuaW5jbHVkZXMoZmFsc2UpO1xuICAvLyBjb25zb2xlLmxvZygnRG9jdW1lbnRUcmFuc2xhdGFibGUnLCBrZXlzLCBjaGVja3MsIGVxdWFsKTtcbiAgcmV0dXJuIGVxdWFsO1xufTtcblxuLy8gRG9jdW1lbnRUcmFuc2xhdGFibGUud2h5RGlkWW91UmVuZGVyID0gdHJ1ZTtcbmNvbnN0IFN0eWxlQ29tcG9uZW50ID0gd2l0aFN0eWxlcyhzdHlsZXMpKERvY3VtZW50VHJhbnNsYXRhYmxlKTtcbmNvbnN0IE1lbW9Db21wb25lbnQgPSBSZWFjdC5tZW1vKFN0eWxlQ29tcG9uZW50LCBhcmVFcXVhbCk7XG5leHBvcnQgZGVmYXVsdCBNZW1vQ29tcG9uZW50O1xuIl19